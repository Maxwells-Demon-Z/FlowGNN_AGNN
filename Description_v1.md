
# TrackGNN 

## Algorithm of TrackGNN 

Given node features and directed adjacent list of one graph which is generated by colliders, the TrackGNN algorithm can figure out which edges in the adjacent list are real, and which edges are not. 

For one graph $G(V,E)$, suppose the input feature and the node embedding of node $v$ are $\mathbf{x}_ v$ and $\mathbf{h}_ v$, the attention of directed edge $(src, dst)$ is $e_ {(src,dst)}$, the input and output messages of node $v$ are $\mathbf{mi}_ v$ and $\mathbf{mo}_ v$, and the sets of source and target nodes of node $v$ are $SRC(v)$ and $DST(v)$. 

The pseudo codes of TrackGNN can be represented as  
$\mathbf{h}_ v^0=MLP_ {input}(\mathbf{x}_ v),\ \forall v\in V$  
$\mathbf{for}\ k=1...K:$  
$\ \ \ \ e_ {(src,dst)}^{(k-1)}=MLP_ {edge}\Big(CONCAT(\mathbf{h}_ {src}^{(k-1)},\mathbf{h}_ {dst}^{(k-1)})\Big),\ \forall(src,dst)\in E$  
$\ \ \ \ \mathbf{mi}_ v^{(k-1)}=\sum_ {u\in SRC(v)}\ \big(e_ {(u,v)}^{(k-1)}\mathbf{h}_ u^{(k-1)}\big),\ \forall v\in V$  
$\ \ \ \ \mathbf{mo}_ v^{(k-1)}=\sum_ {v\in DST(u)}\ \big(e_ {(u,v)}^{(k-1)}\mathbf{h}_ v^{(k-1)}\big),\ \forall v\in V$  
$\ \ \ \ \mathbf{h}_ v^k=\mathbf{h}_ v^{(k-1)}+MLP_ {node}\Big(CONCAT(\mathbf{mi}_ v^{(k-1)},\mathbf{mo}_ v^{(k-1)},\mathbf{h}_ v^{(k-1)})\Big),\ \forall v\in V$  
$e_ {(src,dst)}^K=MLP_ {edge}\Big(CONCAT(\mathbf{h}_ {src}^K,\mathbf{h}_ {dst}^K)\Big),\ \forall(src,dst)\in E$  

Suppose the dimensions of input features and node embeddings are $m$ and $n$ for convenience. The structures of $MLP_ {input}$, $MLP_ {edge}$, and $MLP_ {node}$ are $m\rightarrow n$, $2n\rightarrow n\rightarrow n\rightarrow 1$, and $3n\rightarrow n\rightarrow n\rightarrow n$. 

## Modify to Fit the Framework of FlowGNN

![NE-to-MP](/image/NE-to-MP.png)
![MP-to-NE](/image/MP-to-NE.png)

Thus, the algorithm can be modified as below. It can be divided into four parts - "node embedding", "adapter", "edge embedding", and "message scatter".  
$\mathbf{for}\ k=0...K:$  
$\ \ \ \ node\ embedding:$  
$\ \ \ \ \ \ \ \ \mathbf{if}\ it\ is\ the\ first\ iteration:$  
$\ \ \ \ \ \ \ \ \ \ \ \ \mathbf{h}_ v^0=MLP_ {input}(\mathbf{x}_ v),\ \forall v\in V$  
$\ \ \ \ \ \ \ \ \mathbf{else}:$  
$\ \ \ \ \ \ \ \ \ \ \ \ \mathbf{h}_ v^k=\mathbf{h}_ v^{(k-1)}+MLP_ {node}\Big(CONCAT(\mathbf{mi}_ v^{(k-1)},\mathbf{mo}_ v^{(k-1)},\mathbf{h}_ v^{(k-1)})\Big),\ \forall v\in V$  
$\ \ \ \ adapter:$  
$\ \ \ \ \ \ \ \ Receive\ data\ from\ ``node\ embedding"$  
$\ \ \ \ \ \ \ \ Send\ data\ to\ ``edge\ embedding"$  
$\ \ \ \ edge\ embedding:$  
$\ \ \ \ \ \ \ \ e_ {(src,dst)}^k=MLP_ {edge}\Big(CONCAT(\mathbf{h}_ {src}^k,\mathbf{h}_ {dst}^k)\Big),\ \forall(src,dst)\in E$  
$\ \ \ \ message\ scatter:$  
$\ \ \ \ \ \ \ \ \mathbf{if}\ it\ is\ \mathbf{not}\ the\ last\ iteration:$  
$\ \ \ \ \ \ \ \ \ \ \ \ \mathbf{mi}_ v^k=\sum_ {u\in SRC(v)}\ \big(e_ {(u,v)}^k\mathbf{h}_ u^k\big),\ \forall v\in V$  
$\ \ \ \ \ \ \ \ \ \ \ \ \mathbf{mo}_ v^k=\sum_ {v\in DST(u)}\ \big(e_ {(u,v)}^k\mathbf{h}_ v^k\big),\ \forall v\in V$  

## Detailed Implement 

### "Edge Embedding" 






